#version 150

in vec2 pass_textureCoordinates;
in vec3 surfaceNormal;
in vec3 toLightVector;
in vec3 toCameraVector;
in vec4 shadowCoords;

out vec4 out_colour;


uniform sampler2D shadowMap;
uniform sampler2D modelTexture;
uniform vec3 lightcolour;
uniform float shinedamper;
uniform float reflectivity;
uniform vec3 skycolour;

const float levels = 3.0;


void main(void){

vec3 projectCoords=shadowCoords.xyz / shadowCoords.w;
projectCoords= projectCoords * 0.5 + 0.5;


    vec3 unitNormal = normalize(surfaceNormal);
    vec3 unitLightVector = normalize(toLightVector);

    float nDot1 = max(dot(unitNormal, unitLightVector), 0.0);
    vec3 ambient = skycolour * 0.2; // ambient contribution from sky
    vec3 diffuse = lightcolour * nDot1;
    vec3 totalLight = ambient + diffuse;
    vec3 unitvectortocamera = normalize(toCameraVector);
    vec3 lightdirection = - unitLightVector;
    vec3 reflectedLD = reflect(lightdirection,unitNormal);





    float sf = dot(reflectedLD, unitvectortocamera);
    sf = max(sf, 0.0);
    float df = pow(sf, shinedamper);
    vec3 fs = df * lightcolour * reflectivity;
    vec4 texturecolour = texture(modelTexture,pass_textureCoordinates);
if(projectCoords.x < 0.0 || projectCoords.x>1.0 || projectCoords.y < 0.0 || projectCoords.y>1.0 || projectCoords.z > 1.0 ){
out_colour=vec4(diffuse,1.0) * texturecolour + vec4(fs,1.0);
return;
}

float bias = max(0.02 * (1.0 - dot(unitNormal, unitLightVector)), 0.01);
float currdepth = projectCoords.z;

// PCF (3x3) sampling to soften shadow edges
const float shadowMapSize = 4096.0; // match ShadowFrameBuffer SHADOW_SIZE
float texel = 1.0 / shadowMapSize;
float shadow = 0.0;
for(int x=-1; x<=1; x++){
    for(int y=-1; y<=1; y++){
        float closeDepth = texture(shadowMap, projectCoords.xy + vec2(float(x) * texel, float(y) * texel)).r;
        if(currdepth > closeDepth + bias){
            shadow += 1.0;
        }
    }
}
shadow /= 9.0; // average

// mix between full light and partial shadow (avoid completely black areas)
    float lightFactor = mix(1.0, 0.35, shadow);
    totalLight *= lightFactor;
    out_colour = vec4(totalLight,1.0) * texturecolour + vec4(fs,1.0);


}

